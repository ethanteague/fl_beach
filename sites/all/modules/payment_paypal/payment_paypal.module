<?php
/**
 * @file
 * Implements Paypal payment services for use with Payment.
 */

define('PAYMENT_PAYPAL_API_VERSION', 86);

/**
 * Paypal server expect 2 decimal places for
 * payment fields (forced or rounded).
 */
define('PAYMENT_PAYPAL_AMOUNT_PRECISION', 2);

/**
 * WPP - Only API signature supported (not certificates)
 */
define('PAYMENT_PAYPAL_ENDPOINT_URL', 'https://api-3t.paypal.com/nvp');
define('PAYMENT_PAYPAL_ENDPOINT_SANDBOX_URL', 'https://api-3t.sandbox.paypal.com/nvp');
define('PAYMENT_PAYPAL_ENDPOINT_BETA_SANDBOX_URL', 'https://api-3t.beta-sandbox.paypal.com/nvp');

/**
 * WPS
 */
define('PAYMENT_PAYPAL_REDIRECT_SANDBOX_URL', 'https://www.sandbox.paypal.com/cgi-bin/webscr');
define('PAYMENT_PAYPAL_REDIRECT_LIVE_URL', 'https://www.paypal.com/cgi-bin/webscr');

//Offsite callbacks entries
define('PAYMENT_PAYPAL_RETURN_URL', 'payment_paypal/return_url');
define('PAYMENT_PAYPAL_CANCEL_URL', 'payment_paypal/cancel_url');

define('PAYMENT_PAYPAL_STATUS_REDIRECTED', 'payment_paypal_status_redirected');
define('PAYMENT_PAYPAL_STATUS_RETURNED', 'payment_paypal_status_returned');

/**
 * Implements hook_menu()
 */
function payment_paypal_menu() {
  $items = array();

  $items[PAYMENT_PAYPAL_RETURN_URL . '/%entity_object'] = array(
    'load arguments' => array('payment'),
    'page callback' => 'payment_paypal_return_url',
    'page arguments' => array(2),
    'access callback' => 'payment_paypal_offsite_access',
    'access arguments' => array(2),
    'type' => MENU_CALLBACK,
    'file' => 'payment_paypal.offsite.inc',
  );

  $items[PAYMENT_PAYPAL_CANCEL_URL . '/%entity_object'] = array(
    'load arguments' => array('payment'),
    'page callback' => 'payment_paypal_cancel_url',
    'page arguments' => array(2),
    'access callback' => 'payment_paypal_offsite_access',
    'access arguments' => array(2),
    'type' => MENU_CALLBACK,
    'file' => 'payment_paypal.offsite.inc',
  );

  return $items;
}

/**
 * Custom access handler
 *
 * @param $arg
 *   Argument form menu.
 *   Must be a payment object
 *
 * @return
 *   TRUE if argument is a payment instance
 *   Otherwise, return FALSE
 */
function payment_paypal_offsite_access($arg) {
  if ($arg instanceof Payment) {
    return TRUE;
  }
  return FALSE;
}

/**
 * Implements hook_views_api().
 */
function payment_paypal_views_api() {
  return array(
    'api' => 3,
    'path' => drupal_get_path('module', 'payment_paypal') . '/includes/views',
  );
}

/**
 * Implements hook_perm()
 */
function payment_paypal_permission() {
  $perm = array();

  $perm['administer payment paypal'] = array(
    'title' => t('Administer paypal backend'),
    'description' => t('Allow user to view some related data about paypal payment.'),
    'restrict access' => TRUE,
  );

  return $perm;
}

/**
 * Implements hook_payment_method_controller_info().
 */
function payment_paypal_payment_method_controller_info() {
  $method_controllers = array('PaymentPaypalExpressCheckoutMethodController');
  if (module_exists('payment_credit_card')) {
    $method_controllers[] = 'PaymentPaypalDirectMethodController';
  }
  return $method_controllers;
}

/**
 * Implements hook_entity_load().
 */
function payment_paypal_entity_load(array $entities, $entity_type) {
if ($entity_type == 'payment_method') {

    $pmids = array();
    foreach ($entities as $payment_method) {
      if (in_array($payment_method->controller->name, array('PaymentPaypalDirectMethodController', 'PaymentPaypalExpressCheckoutMethodController'), TRUE)) {
        $pmids[] = $payment_method->pmid;
      }
    }

    //Add additional data to paypal payment methods
    if ($pmids) {
      $result = payment_paypal_method_load_data($pmids);
      if ($result) {

        foreach ($result as $pmid => $data) {
          $payment_method = $entities[$pmid];
          foreach ($data as $property => $values) {
            $payment_method->controller_data[$property] = $values;
          }
        }
      }
    }
  }
}

/**
 * Implements hook_entity_delete()
 */
function payment_paypal_entity_delete($entity, $type) {
  if ($type === 'payment') {
    payment_paypal_paypal_payment_delete($entity->pid);
  }
  elseif ($type === 'payment_method' && in_array($entity->controller->name, array('PaymentPaypalDirectMethodController', 'PaymentPaypalExpressCheckoutMethodController'), TRUE)) {
    payment_paypal_paypal_payment_delete(NULL, $entity->pmid);
  }
}

/**
 * Implements hook_ENTITY_TYPE_ACTION().
 */
function payment_paypal_payment_method_insert(PaymentMethod $payment_method) {
  if (in_array($payment_method->controller->name, array('PaymentPaypalDirectMethodController', 'PaymentPaypalExpressCheckoutMethodController'),TRUE)) {

    $payment_method->controller_data += $payment_method->controller->controller_data_defaults;

    $values = array_merge($payment_method->controller_data, array(
      'pmid' => $payment_method->pmid,
    ));
    $values['settings'] = serialize($values['settings']);

    $query = db_insert('payment_paypal_method');
    $query->fields($values);
    $query->execute();
  }
}

/**
 * Implements hook_ENTITY_TYPE_ACTION().
 */
function payment_paypal_payment_method_update(PaymentMethod $payment_method) {
  if (in_array($payment_method->controller->name, array('PaymentPaypalDirectMethodController', 'PaymentPaypalExpressCheckoutMethodController'), TRUE)) {

    $values = array_merge($payment_method->controller_data, array(
      'pmid' => $payment_method->pmid,
    ));
    $values['settings'] = serialize($values['settings']);

    $query = db_update('payment_paypal_method');
    $query->fields($values);
    $query->condition('pmid', $payment_method->pmid);
    $query->execute();
  }
}

/**
 * Implements hook_ENTITY_TYPE_ACTION().
 */
function payment_paypal_payment_method_delete($entity) {
  if (in_array($entity->controller->name, array('PaymentPaypalDirectMethodController', 'PaymentPaypalExpressCheckoutMethodController'),TRUE)) {
    db_delete('payment_paypal_method')
      ->condition('pmid', $entity->pmid)
      ->execute();
  }
}

/**
 * Implements hook_payment_status_info()
 */
function payment_paypal_payment_status_info() {
  return array(
    new PaymentStatusInfo(array(
      'description' => t('Payment have been redirect to the PayPal server.'),
      'status' => PAYMENT_PAYPAL_STATUS_REDIRECTED,
      'parent' => PAYMENT_STATUS_PENDING,
      'title' => t('Redirected'),
    )),
    new PaymentStatusInfo(array(
      'description' => t('Payment returns by Paypal server. It needs to be complete.'),
      'status' => PAYMENT_PAYPAL_STATUS_RETURNED,
      'parent' => PAYMENT_STATUS_PENDING,
      'title' => t('Returned'),
    )),
  );
}

/**
 * Implements hook_theme()
 */
function payment_paypal_theme($existing, $type, $theme, $path) {
  $path = drupal_get_path('module', 'payment_paypal') . '/includes/theme';

  return array(
    'payment_paypal_credit_card_img' => array(
      'variables' => array('credit_cards' => array()),
      'path' => $path,
      'file' => 'payment_paypal.theme.inc',
    ),
  );
}

/**
 * Function helper to encrypt a passwd
 */
function payment_paypal_crypt_passwd($key, $string) {
  return base64_encode(mcrypt_encrypt(MCRYPT_RIJNDAEL_256, md5($key), $string, MCRYPT_MODE_CBC, md5(md5($key))));
}

/**
 * Function helper to decrypt a passwd
 */
function payment_paypal_decrypt_passwd($key, $encrypted) {
  return rtrim(mcrypt_decrypt(MCRYPT_RIJNDAEL_256, md5($key), base64_decode($encrypted), MCRYPT_MODE_CBC, md5(md5($key))), "\0");
}

/**
 * Function helper to decrypt passwd
 * of API credential.
 * Should be used only when needed (calling paypal API)
 *
 * For e.g, by doing it dynamically into a hook_entity_load,
 * passwd will pass through in clear into a lot of process, such
 * as exported method with features module... !
 *
 * @return
 *   Decrypted password on success
 *   Crypted password otherwise
 */
function payment_paypal_get_decrypted_passwd($crypted) {
  $passwd = $crypted;

  $key = variable_get('payment_paypal_default_crypt_password_key', FALSE);
  if (!$key) {
    watchdog('payment_paypal', 'Unable to retrieve key crypt, you must edit your settings.php and add this key', array(), WATCHDOG_ERROR);
  }
  else {
    $passwd = payment_paypal_decrypt_passwd($key, $crypted);
  }
  return $passwd;
}

/**
 * Function helper to retrieve
 * data from pmids
 *
 * @param $pmids
 *   An array of direct paypal payment method pmids
 * @return
 *   An array keyed by pmid and containing
 *   additionnal method fields
 */
function payment_paypal_method_load_data(array $pmids) {

  $query = db_select('payment_paypal_method', 'ppm')
    ->fields('ppm')
    ->condition('ppm.pmid', $pmids, 'IN');

  $result = $query->execute()->fetchAllAssoc('pmid');
  foreach ($result as $pmid => $properties) {
    $result[$pmid]->settings = unserialize($properties->settings);
  }

  return $result;
}

/**
 * Load a payment paypal data object depends on :
 *
 * @param $pid
 *   a payment ID
 * @param $pmid
 *   a payment method ID
 * @param $last
 *   A boolean indicating if paypal payments
 *   have been found, only return the last paypal payment object.
 *
 * @return
 *   - An array of paypal payments object keyed by correlation ID
 *   - An empty array otherwise.
 */
function payment_paypal_paypal_payment_load($pid = NULL, $pmid = NULL, $last = FALSE) {
  $paypal_payments = array();

  if (!$pid && !$pmid) {
    return $paypal_payments;
  }

  $query = db_select('payment_paypal_payment', 'ppp')
    ->fields('ppp');

  if ($pid) {
    $query->condition('ppp.pid', $pid);
  }

  if ($pmid) {
    $query->condition('ppp.pmid', $pmid);
  }

  if ($last) {
    $query->orderBy('timestamp', 'DESC');
    $query->range(0, 1);
  }

  $result = $query->execute()->fetchAll();
  foreach ($result as $data) {
    $data->data = unserialize($data->data);
    $paypal_payments[$data->correlation_id] = $data;
  }

  return $paypal_payments;
}

/**
 * Log paypal payment data into database.
 *
 * It could be an insert or update SQL clause.
 *
 * Unique identifier are correlation ID and payment ID.
 * @param $payment
 *   Payment object associated to the paypal payment
 * @param $correlation_id
 * @param $transaction_id
 * @param $ack
 * @param $timestamp
 *   Timestamp payment paypal. So should be numeric
 * @param $data
 *   An array of other data to store
 */
function payment_paypal_paypal_payment_log(Payment $payment, $correlation_id, $transaction_id, $ack, $timestamp, $data) {

  db_merge('payment_paypal_payment')
    ->key(array(
      'correlation_id' => $correlation_id,
    ))
    ->fields(array(
      'pid' => $payment->pid,
      'pmid' => $payment->method->pmid,
      'transaction_id' => $transaction_id,
      'ack' => $ack,
      'timestamp' => $timestamp,
      'data' => serialize($data),
    ))
    ->execute();
}

/**
 * Delete paypal payment data returns from paypal server
 *
 * @param $pid
 *   Payment ID to delete association (only one row)
 * @param $pmid
 *   Payment method ID to delete associations. (further rows)
 *
 * NOTE : At least one param must be provided
 */
function payment_paypal_paypal_payment_delete($pid = NULL, $pmid = NULL) {

  if (!$pid && !$pmid) {
    return FALSE;
  }

  $query = db_delete('payment_paypal_payment');

  if ($pid) {
    $query->condition('pid', $pid);
  }
  if ($pmid) {
    $query->condition('pmid', $pmid);
  }

  $query->execute();
}